/* Атомарность на уровне оператора. */

CREATE TABLE SCOTT.TMP2 (cnt INT);
INSERT INTO SCOTT.TMP2 VALUES (0);

CREATE TABLE SCOTT.TMP (x INT CHECK (x > 0));

CREATE OR REPLACE TRIGGER SCOTT.T_TRIGGER
  BEFORE INSERT OR DELETE ON SCOTT.TMP
  FOR EACH ROW
BEGIN
  IF (inserting) THEN
    UPDATE SCOTT.TMP2
       SET cnt = cnt + 1;
  ELSE
    UPDATE SCOTT.TMP2
       SET cnt = cnt - 1;
  END IF;
  dbms_output.put_line('Триггер сработал и обновил ' || SQL%ROWCOUNT || ' строку');
END;

INSERT INTO SCOTT.TMP VALUES(1);
INSERT INTO SCOTT.TMP VALUES(-1);

SELECT * FROM scott.tmp2;
-------------------------
CNT
---
  1	

  Итак, в таблицу SCOTT.TMP была успешно вставлена одна строка, и мы 
надлежащим образом получили сообщение "Триггер сработал и обновил 1 строку". 
Следующий оператор INSERT нарушает ограничение целостности, имеющееся в таблице SCOTT.TMP. 
Наличие сообщения DBMS_OUTPUT свидетельствует о том, что триггер в таблице SCOTT.TMP 
действительно сработал. Он успешно произвел свои обновления таблицы SCOTT.TMP2. 
Можно было ожидать, что SCOTT.TMP2 теперь содержит значение 2, но на самом деле оно равно 1. 
  СУБД Oracle сделала исходный оператор INSERT атомарным ­ первоначальный INSERT INTO SCOTT.TMP 
является оператором, и любой сторонний эффект, порожденный этим оператором, считается его частью.
СУБД Oracle достигает такой атомарности уровня оператора за счет того, что молча помещает каждое
обращение к базе данных внутрь SAVEPOINT. Предыдущие два оператора INSERT в действительности трактавались так:

SAVEPOINT оператор1 ;
INSERT INTO SCOTT.TMP VALUES(1);
Если возникла ошибка , то откатить оператор1 ;
SAVEPOINT оператор2 ;
INSERT INTO SCOTT.TMP VALUES (-1) ;
Если возникла ошибка , то откатить оператор2 ; 

В Oracle такая атомарность на уровне оператора распространяется настолько глубоко, 
насколько это необходимо. Если в предыдущем примере оператор INSERT INTO SCOTT.TMP запустит триггер, 
который обновляет другую таблицу, и эта другая таблица имеет триггер, осуществляющий удаление в третьей 
таблице (и т.д. и т.п.), то либо вся работа завершится успешно, либо не будет выполнено ни одного действия. 
Чтобы обеспечить это, не придется писать какой-то специальный код - просто именно так все работает. 

/* Атомарность на уровне процедуры. */

CREATE OR REPLACE PROCEDURE SCOTT.tmp_prc IS
BEGIN
  INSERT INTO SCOTT.TMP VALUES (1);
  INSERT INTO SCOTT.TMP VALUES (-1);
END;

DELETE FROM SCOTT.TMP;
UPDATE SCOTT.TMP2 SET cnt = 0;
COMMIT;

SELECT * FROM SCOTT.TMP;
0 записей выбрано

SELECT * FROM SCOTT.TMP2;
CNT
---
  0

Запускаем процедуру и проверяем.

BEGIN SCOTT.tmp_prc; END;

SELECT * FROM SCOTT.TMP;
0 записей выбрано

SELECT * FROM SCOTT.TMP2;
CNT
---
  0

Oracle трактует вызов хранимой процедуры как атомарный оператор. 
Клиент отправляет блок кода BEGIN SCOTT.tmp_prc; END; и Oracle помещает его в оболочку SAVEPOINT. 
Поскольку процедура SCOTT.tmp_prc терпит отказ, Oracle восстанавливает базу данных в состояние, 
которое она имела в точке, непосредственно предшествовавшей вызову SCOTT.tmp_prc.

Теперь, если мы отправим слегка отличающийся блок, то получим совершенно другие результаты:

BEGIN
  SCOTT.tmp_prc;
EXCEPTION
  WHEN OTHERS THEN
    dbms_output.put_line('Error! ' || SQLERRM);
END;

Триггер сработал и обновил 1 строку
Триггер сработал и обновил 1 строку
Error! ORA-02290: нарушено ограничение целостности CHECK(SCOTT.SYS_C002648654)

SELECT * FROM SCOTT.TMP;
  X
---
  1

SELECT * FROM SCOTT.TMP2;
CNT
---
  1
  
ROLLBACK;

  СУБД Oracle считает "оператором" блок кода, отправленный клиентом. Этот оператор завершается успешно 
за счет самостоятельного перехвата и игнорирования ошибки, так что конструкция " Если возникла ошибка, 
то откатить ... " не вступает в действие и после выполнения Oracle не производит откат к точке сохранения.
Следовательно, частичная работа, сделанная SCOTT.tmp_prc, сохраняется. Причина предохранения этой частичной работы в 
первую очередь объясняется наличием атомарности на уровне оператора внутри процедуры SCOTT.tmp_prc каждый оператор в 
SCOTT.tmp_prc является атомарным. 
  Процедура SCOTT.tmp_prc становится клиентом Огасlе, когда отправляет свои два оператора INSERT . 
Каждый оператор INSERT либо целиком успешен, либо нет. Об этом свидетельствует тот факт, что мы можем видеть, что 
триггер таблицы SCOTT.TMP запускалcя два раза и дважды обновил SCOTT.TMP2, хотя счетчик в SCOTT.TMP2 отражает только 
один оператор UPDATE . 
Второй оператор INSERT , выполненный в SCOTT.tmp_prc, находится внутри неявной оболочки SAVEPOINT . 
